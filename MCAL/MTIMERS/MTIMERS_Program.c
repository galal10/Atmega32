/*
 * MTIMER_Program.c
 *
 *  Created on: Aug 25, 2023
 *      Author: galal
 */

#include "../../LIB/LBITS.h"
#include "../../LIB/LSTD_TYPES.h"
#include "MTIMER0_Config.h"
#include "MTIMER1_Config.h"
#include "MTIMER2_Config.h"
#include "MTIMERS_Interface.h"
#include "MTIMERS_Private.h"

static void (*TIMER0_CallBack[TIMER0_ISR_VECTORS])(void) = {NULL_PTR};
static void (*TIMER1_CallBack[TIMER1_ISR_VECTORS])(void) = {NULL_PTR};
static void (*TIMER2_CallBack[TIMER2_ISR_VECTORS])(void) = {NULL_PTR};

void MTIMER0_Vid_Init(void)
{
	/* select the suitable pre scaler */
	/* clear cs00, cs01, cs02 bits */
	TCCR0 &= 0xF8;
	TCCR0 |= TIMER0_SET_PRESCALER;
	/* select mode */
#if TIMER0_SET_MODE == TIMER0_NORMAL_MODE
	CLR_BIT(TCCR0, WGM00);
	CLR_BIT(TCCR0, WGM01);

#elif TIMER0_SET_MODE == TIMER0_PHASECORRECT_MODE
	SET_BIT(TCCR0, WGM00);
	CLR_BIT(TCCR0, WGM01);

#elif TIMER0_SET_MODE == TIMER0_CTC_MODE
	CLR_BIT(TCCR0, WGM00);
	SET_BIT(TCCR0, WGM01);

#elif TIMER0_SET_MODE == TIMER0_FASTPWM_MODE
	SET_BIT(TCCR0, WGM00);
	SET_BIT(TCCR0, WGM01);

#else
	#error "TIMER0 Mode is not valid"

#endif

	/* Timer0 OC0 PIN */
	/* CLR bit COM00, COM01 */
	TCCR0 &= 0xCF;
	TCCR0 |= (TIMER0_SET_OC0_PIN_MODE << COM00);
}

void MTIMER1_Vid_Init(void)
{
	/* select the suitable pre scaler */
	/* clear CS12,CS11,CS10 bits */
	TCCR1B &= 0xF8;
	TCCR1B |= TIMER1_SET_PRESCALER;

#if TIMER1_SET_MODE == TIMER1_NORMAL_MODE
	CLR_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_8_bit
	SET_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_9_bit
	CLR_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_10_bit
	SET_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_CTC_OCR1A
	CLR_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_FAST_PWM_8_bit
	SET_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_FAST_PWM_9_bit
	CLR_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_FAST_PWM_10_bit
	SET_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	CLR_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_PWM_PHASE_AND_FREQUENCY_CORRECT_ICR1
	CLR_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_PWM_PHASE_AND_FREQUENCY_CORRECT_OCR1A
	SET_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_ICR1
	CLR_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_OCR1A
	SET_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	CLR_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_CTC_ICR1
	CLR_BIT(TCCR1A, WGM10);
	CLR_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_FAST_PWM_ICR1
	CLR_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

#elif TIMER1_SET_MODE == TIMER1_FAST_PWM_OCR1A
	SET_BIT(TCCR1A, WGM10);
	SET_BIT(TCCR1A, WGM11);
	SET_BIT(TCCR1B, WGM12);
	SET_BIT(TCCR1B, WGM13);

#else
	#error "TIMER1 Mode is not valid"

#endif

	/* Timer1 OC1A, OC1B PINs */
	/* CLR bit COM1A1, COM1A0, COM1B1, COM1B0 */
	TCCR1A &= 0x0F;

	/* Output Compare Pins Behavior of Phase Correct and Phase and Frequency Correct PWM modes */
#if TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_8_bit || TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_9_bit \
		|| TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_10_bit || TIMER1_SET_MODE == \
		TIMER1_PWM_PHASE_AND_FREQUENCY_CORRECT_ICR1 || TIMER1_SET_MODE == \
		TIMER1_PWM_PHASE_AND_FREQUENCY_CORRECT_OCR1A || TIMER1_SET_MODE == \
		TIMER1_PWM_PHASE_CORRECT_ICR1 || TIMER1_SET_MODE == TIMER1_PWM_PHASE_CORRECT_OCR1A

	TCCR1A |= (TIMER1_OC1A_PHASE << COM1A0) | (TIMER1_OC1B_PHASE << COM1B0);

	/* Output Compare Pins Behavior of non-PWM mode */
#elif TIMER1_SET_MODE == TIMER1_NORMAL_MODE || TIMER1_SET_MODE == TIMER1_CTC_ICR1 || TIMER1_SET_MODE == TIMER1_CTC_OCR1A
	TCCR1A |= (TIMER1_OC1A_NON_PWM << COM1A0) | (TIMER1_OC1B_NON_PWM << COM1B0);

	/* Output Compare Pins Behavior of fast-PWM mode */
#elif TIMER1_SET_MODE == TIMER1_FAST_PWM_8_bit || TIMER1_SET_MODE == TIMER1_FAST_PWM_9_bit || TIMER1_FAST_PWM_10_bit || \
		TIMER1_SET_MODE == TIMER1_FAST_PWM_ICR1 || TIMER1_SET_MODE == TIMER1_FAST_PWM_OCR1A

	TCCR1A |= (TIMER1_OC1A_FAST_PWM << COM1A0) | (TIMER1_OC1B_FAST_PWM << COM1B0);


#else
	#error "TIMER1 Compare Output Mode is not valid"

#endif
}

#endif
}

}

